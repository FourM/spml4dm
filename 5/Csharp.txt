■カテゴリ / ■テンプレート
C#（シーシャープ）とは、マイクロソフトが開発したマルチパラダイムプログラミング言語。強い型付け、命令型、宣言型、手続き型、関数型、ジェネリック、オブジェクト指向の要素を持つ。
マイクロソフトのソフトウェアフレームワークである.NET Frameworkとともに作られ、Ecma International[1]および国際標準化機構 (ISO)[2] によって標準化されており、日本においても日本工業規格 (JIS)[3]によって採択された。


開発にはボーランド社のTurbo PascalやDelphiを開発したアンダース・ヘルスバーグを筆頭に多数のDelphi開発陣が参加している。
C#は共通言語基盤（共通言語ランタイムなど）が解釈する共通中間言語にコンパイルされて実行される。基本的な書式がC言語風になっているため、初見の構文はサン・マイクロシステムズ社によるJavaに近いと言われるが、実際の構文はDelphiに準じており、C言語風ということもありC++ Builderの独自拡張構文に極めて近い内容となっている。またプロパティやデリゲートなどDelphiの構文そのまま、もしくは名称変更しただけの機能となっているものが多い。
自動ボックス化、デリゲート、プロパティ、インデクサ、カスタム属性、ポインタ演算操作、構造体（値型オブジェクト）、多次元配列、可変長引数、などの機能を持つ。また、Javaと同様に大規模ライブラリ、プロセッサ・アーキテクチャに依存しない実行形態、ガベージコレクション、JITコンパイルによる実行の高速化、などが実現されている（もっともこれらはC#の機能というより.NET Frameworkによるものである）。
.NET構想における中心的な開発言語であり、XML WebサービスやASP.NETの記述にも使用される。他の.NET系の言語でも記述可能だが、生産性・機能においてC#が最も優れるとされる。マイクロソフトの統合開発環境では、Microsoft Visual C#がC#に対応している。
共通言語仕様のCLSによって、他のCLS準拠の言語（Visual Basic .NETやVisual C++ (C++/CLI)など）と相互に連携することができる。他言語で記述されたクラスを継承することも、またその逆も可能である。
さまざまな意味において、基盤であるCLIの機能をもっとも反映している言語であるといえる。C#にある組み込み型のほとんどは、CLIフレームワークに実装されている値型と対応している。しかし、C#の言語仕様はコンパイラのコード生成については何も言及していない。つまり、CLRに対応しなければならないとか、共通中間言語 (CIL) などの特定のフォーマットのコードを生成しなければならないとかいうことは述べられていない。そのため、理論的にはC++やFORTRANのように環境依存のマシン語を生成することも可能である。しかし、現在存在するすべてのC#コンパイラはCLIをターゲットにしている。
C#では、CやC++と比較してさまざまな制限や改良が加えられている。その例を次に挙げる。
部分型 (Partial Type) が導入された。以下のようにクラスや構造体の宣言にpartial修飾子をつけることで、その宣言を分割することができる。
これは以下と同義である:
これによって、巨大なクラスを分割したり、自動生成されたコードを分離したりすることができる。partial 修飾子はすべての宣言につける必要がある。
ジェネリクスが導入された。これは.NET Framework 2.0の機能である。クラス、構造体、インタフェース、デリゲート、メソッドに対して適用することができる。.NETのGenericsはC++のテンプレート、あるいはJavaにおけるそれとも異なるもので、コンパイルによってではなく実行時にランタイムによって特殊化される。これによって異なる言語間の運用を可能にし、リフレクションによって型パラメタに関する情報を取得することができる。また、where節によって型パラメタに制約を与えることができる。一方、C++のように型パラメタとして式を指定することはできない。なお、ジェネリックメソッドの呼び出し時に引数によって型パラメタが推論できる場合、型パラメタの指定は省略できる。
静的クラスが導入された。static属性をクラスの宣言につけることで、クラスはインスタンス化できなくなり、静的なメンバしか持つことができなくなる。
yieldキーワードによるコルーチンを使うことで、イテレータを楽に実装できるようになった。
クロージャの機能を提供する匿名デリゲートが導入された。
プロパティのget もしくは setアクセサのどちらかにアクセス修飾子を指定することでアクセス制御が別個にできるようになった。次の例では、getアクセサはpublic、setアクセサはprivateである。
nullを保持できる値型、Nullableが導入された。
int?はNullable<int>の糖衣構文である。また、nullを保持しているNull許容型のインスタンスをボックス化しようとすると、単に空参照 (null) に変換される[4]。
また、null結合演算子 (??)が導入された。これは、nullでない最初の値を返す。
この演算子は主にNullable型を非Nullable型に代入するときに使われる。
var キーワードが導入され、型推論を利用したローカル変数の宣言ができるようになった。
拡張メソッドが導入された。既存のクラスを継承して新たなクラスを定義することなく新たなインスタンスメソッドを追加定義することができる。具体的には、独自の静的クラス内に this 修飾子をつけた、拡張メソッドを追加する対象の型の引数を最初に持つメソッドを定義することによって、通常の静的メソッドとしての呼び出しの他に指定した型のインスタンスメソッドとしての呼び出しを行うことができるメソッドを作ることができる。以下に例を挙げる:
この例は string 型に、文字列 （string 型のインスタンス）を指定した回数繰り返したものを返すメソッド Repeat を追加している。このメソッドは、以下のように呼び出すことができる:
また、列挙型やインターフェースなど本来メソッドの実装を持ち得ない型に、見かけ上インスタンスメソッドを追加することも可能である。以下に例を挙げる:
このメソッドは以下のように呼び出すことができる:
部分メソッドが導入された。部分型（partial 型）内で定義された private で、かつ戻り値が void のメソッドに partial 修飾子をつけることでメソッドの宣言と定義を分離させることができる。定義されていない部分メソッドは何も行わず、何らエラーを発生させることもない。例えば:
上のコードにおいて Method() を呼び出すと、Did something. と表示されるだけだが、ここで以下のコード:
を追加した上で Method() を呼び出すと、[DEBUG: Some message] Did something. と表示される。
匿名メソッドをより簡略化した記法として、ラムダ式が導入された。この名前はラムダ計算に由来する。
以下の匿名メソッド
は、ラムダ式を使って次のように記述できる:
ラムダ式は匿名メソッドと同様に扱えるが、式形式のラムダがExpression<TDelegate>型として扱われた場合のみ匿名メソッドとして扱われず、コンパイラによって式木を構築するコードに変換される。匿名デリゲートが実行前にコンパイルされたCILを保持するのに対し、式木はCILに実行時コンパイル可能であるDOMのような式の木構造そのものを保持する。これはLINQクエリをSQLクエリなどに変換する際に役立つ。
以下は、3つの任意の名前の変数、整数、括弧、及び四則演算子のみで構成された式を逆ポーランド記法に変換する汎用的なコードである:
オブジェクトの初期化が式として簡潔に記述できるようになった。
また、コレクションの初期化も同様に簡潔に記述できるようになった。
但し、上のコードでは匿名の変数に便宜的に __p、__l、__d と命名している。実際はプログラマはこの変数にアクセスすることはできない。
プロパティをより簡潔に記述するための自動実装プロパティが導入された。プロパティの定義に get; set; と記述することで、プロパティの値を保持するための匿名のフィールド（プログラマは直接参照することはできない）と、そのフィールドにアクセスするためのアクセサが暗黙に定義される。また、C# 5.0 までは get;とset;のどちらか片方だけを記述することは出来なかったが、C# 6.0 からは get; のみが可能。以下のコード:
は、以下のようなコードに相当する動作をする:
但し、上のコードでは匿名のフィールドに便宜的に __value と命名している。実際はプログラマはこのフィールドにアクセスすることはできない。
一時的に使用される型を簡単に定義するための匿名型が導入された。以下に例を挙げる:
上の式は、以下の内容のクラスを暗黙に定義する。定義されたクラスは匿名であるが故にプログラマは参照できない。
同じ型、同じ名前のプロパティを同じ順序で並べた匿名型は同じであることが保証されている。即ち、以下のコード:
において、her.GetType() == him.GetType() は true である。
new キーワードを用いた配列の宣言の際、型を省略できるようになった。匿名型の配列を宣言する際に威力を発揮する。
LINQ をサポートするために、クエリ式が導入された。これは SQL の構文に類似しており、最終的に通常のメソッド呼び出しに変換されるものである。以下に例を示す:
上のコードは以下のように変換される:
C# 3.0で追加された構文の多くは式であるため、より巨大な式（当然クエリ式も含まれる）の一部として組み込むことができる。旧来複数の文に分けたり、作業用の変数を用意して記述していたコードを単独の式としてより簡潔に記述できる可能性がある。
dynamicキーワードが導入され、動的型付け変数を定義できるようになった。dynamic型として宣言されたオブジェクトに対する操作のバインドは実行時まで遅延される。
VBやC++に実装されているオプション引数・名前付き引数が、C#でも利用できるようになった。
ジェネリクスの型引数に対してin、out修飾子を指定することにより、ジェネリクスの共変性・反変性を指定できるようになった。
C#の言語仕様は標準化団体Ecma Internationalを通じて公開・標準化されており、第三者がマイクロソフトとは無関係に実装することができる。 現段階で、C#の実装は次の5つが知られている。

