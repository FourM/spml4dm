Prolog（プロログ）は、非手続き型プログラミング言語の一つ。論理型言語に分類される。名称は、論理を使ったプログラミングを意味するフランス語「programmation en logique」（英語でprogramming in logic）に由来している[1][2]。


1972年ごろにフランスのアラン・カルメラウアーとフィリップ・ルーセルによって考案された[1]。
成立の事情から、Prolog プログラムは論理式とみなされ、その実行は述語論理によって述語が定義された環境における定理証明に擬して解釈されることが多い。利用者は論理プログラミングの枠組みを、取り分け述語論理を学習することで、この枠組みに極めて忠実なこの言語の基礎的な構造のほとんどを理解できる。その言語仕様はこの枠組み以外には考案者たちも含めてそれ以上の拡張をほとんど行っていないため、他のプログラム言語とは異なり、学習しなくてはならない概念や用語もまた、述語論理のものだけでこと足りる。計算機科学の新しい概念や新しい手法とは無縁である。
Prolog のプログラムは一階述語論理に基づいてデータ間の関係を示す命題として記述され、処理系がそれらに単一化(ユニフィケーション)と呼ばれるパターンマッチングを施しながら、与えられた命題が成立するか再帰的手続きによって探索している。
プログラムの実行は述語集合が定義された環境の元で、質問することによってなされるが、これは反駁という述語論理的な証明過程を模して、処理系が用意する導出木と呼ばれるグラフをたどって解を得る過程である。 Prolog のもととなるこの演繹手法は導出と呼ばれ、自動定理証明の研究において Prolog 開発以前からよく知られていた。Prolog は、導出において節を頭部が一つの命題からのみなるホーン節に限定したもので、この場合の導出をSLD導出と呼ぶ。ホーン節に限定しているということは、つまり、Prolog は任意の述語をそのまま扱えるわけではない。Prolog が述語の形式をホーン節に限定した理由は、もし頭部に項の連言を認めるならば、導出時の計算量が爆発的に増大して、全ての解を得ることの保証が難しくなることが必至だからである。
述語論理を論理的な背景に持つことによって、Prolog のプログラムはその正しさを確認することが比較的容易である。同時に、プログラマは Prolog でプログラミングすることが何を意味するかを明確に理解した上で、プログラムを書いていくことができる。
上記は Prolog の一つの解釈である。一方、Prolog というプログラム言語を述語論理という枠にはめないで捉える立場もある。導出、単一化、非決定性、双方向性、リレーショナルデータベースといったこの言語に独特の機能とその表現力、記述力に着目し、そのプログラム言語としての可能性を率直に評価しようとするものだ。
新たに Prolog を学びたいと思う人は、他のプログラム言語を全く知らなくても、ソフトウェア科学的な予備知識や概念に不通であっても、単一化という単純なルールをほとんど唯一の基軸として、パズル的な、あるいはゲーム的な感覚にだけ導かれて、プログラムを簡単に書き進むことができる。さらに、どの言語にも比して平坦で、平明な言語構造を持つ Prolog はラベル名（アトム、関数名、述語名）に適切な意味性を付与することにより、自然言語の領域にも接近したプログラミングが期待できるほとんど唯一の言語でもある。
十分述語論理的な教養を持った上で Prolog を学び、そのプログラムを書くならば、短期間で高度で安定したプログラムを書くことができる。しかし、それを前提としないでも、Prolog は冒険的で、未知の領域に満ちたプログラム言語なのである。
実はこれらの主張は、述語論理的な主張に隠れて、これまであまり強調されたことがなかった。
このような立場や主張が生まれる背景には、Prolog が期待されたほどにはソフトウェア革新の担い手になり得ていない理由が、その後の数理論理学の学問的な評価をもって、プログラム言語としての可能性を十分検証することを放棄して、定理証明といった狭い目的へ封じ込めようとする風潮を生んだことにある、という反省がある。そのことを踏まえて、Prolog が述語論理から成立したことにこだわらず、実在するプログラム言語として自由な視点からこの言語を見直そうとするものである。
Prolog は LISP の資産の多くを継承して間違いなく記号処理用の言語であるが、人工知能言語として分類されることも多い。これは、人工知能の世界では述語論理が古くから理論的な柱の一つとなっているからである。述語論理を基礎とするトップ・ダウン式の問題解決と同じく述語論理を基礎とする Prolog の駆動機構の相性は当然良いため、人工知能研究に広く利用されてきた。特にエキスパートシステムで多用されるプロダクションシステムにおいては、ルールを自然に自ら動的に変更できる能力を持つことと、後ろ向き推論と呼ばれる推論が Prolog の導出過程そのものであることから、その最も主要な記述言語の位置を占めてきた。
Prolog は一階の述語論理に対応することから論理型言語に分類される汎用言語であるが、その主張の一行一行を独立して論理式とほとんど等価な表現で行うことから、最も代表的な宣言型言語と見なされている。Prolog のプログラム単位である述語の各節の本体に現れる質問単位である副目標数は平均5個以内と極めて少ない。この副目標と各節の頭部に現れる引数の組み合わせによって得られる関係が述語の意味を構成している考えられる。これが宣言型とされるゆえんである。
Prologの自然な定義では、 ここで示した <副目標_1> <副目標_2> が、一つの述語において、高々 <副目標_5> くらいまでに収まる。
単一化は1960年代の述語論理理論の発展の鍵となった概念であるが、Prolog が述語論理に導かれて機械による自動証明を実現するためのプログラム言語として成立したことから、必然的にこの言語の必須の最も重要な機構となった。単一化は副目標(質問)と対応する定義節の頭部のパターンが完全に一致するか、調べることで、節の選択[3]を可能にする。基本的な言語仕様の章で詳述するが、Prolog の実行順序等の制御は単一化のからくりを利用してプログラミングされる。
簡単なからくりでかつ極めて強力な単一化であるが実行コストも大きい、すなわち実行速度が遅くなる原因となる。さらに、パターンとして認識することと引き換えに、引数での関数評価は不可能になった。独立して節の本体で式評価を記述しなくてはならないため、数値計算ではやや冗長になる。 これらの点は、単一化の強力さとのトレードオフの関係になっている。
型付けは動的型付けに分類できるが、言語仕様の中に型概念は登場しない。上記の単一化、バックトラッキング、と論理変数の束縛においては独特のものがあり、その実行は型推論の実行過程に酷似している。既に Prolog はその引数の引渡し時に単一化という厳密なパターンマッチングを施すことに多大なコストを掛けた。単一化だけでプログラムをコントロールできる言語が Prolog であるといっても過言ではない。この単一化のみによる簡素で強力なプログラムコントロールの足を引っ張ることに成り兼ねない、型付けの強化は、Prolog 言語とその支持者によって受け入れられることはないだろう。
Prolog は言語による思考をモデル化して主語・述語といった意味での文中の述語を特に重視して記述する系である。この一点からも、対象物を中心に記述していくオブジェクト指向とは距離が大きい。述語論理以前にオブジェクトありきとする立場を一般には取らない。
いくつかの処理系では、オブジェクト指向言語としての拡張が行なわれているが、オブジェクトを中心に設計されることは、論理プログラミングを重視して記述される限りほとんどない。分類するならば、非オブジェクト指向言語に分類される。
Prolog はオブジェクト指向とは疎遠であるが、一方、述部を重視する系であるという点から見ても、モジュラープログラミングとは近い関係にある。Prolog の述語をモジュールとして捉えた場合、多くは再帰的で宣言的であり、情報強度は極めて強く、情報結合度は極めて弱い。引数にはリスト以外の構造体(複合項)が来ることはほとんどなく明解であり、記述単位は数行と極めて短くかつ記述は簡潔である。モジュラープログラミングを突き詰めたものが Prolog だといってもよいように見える。しかし、Prolog をモジュラープログラミングとして評価した場合、疑問符の付くであろう部分もないわけではない。それはPrologの引数の入力・出力の関係が多く場合双方向であり、意味的にも多義性を持つという点である。モジュラープログラミングは「〜を〜する」というような単一機能にまとめることが推奨されたが、この原則に反する。さらにPrologは複数の解を示すことがありうる。この性質を非決定性(後述)というが、実はこのことは定義された述語全体がコルーチンでありうることを意味する。単一の入口点による制御を良しとするモジュラープログラミングの原則にここでも反する。
後に述べるが Prolog の述語はその構造が頭部と本体と分かれていて、本体はルールを意味するため、全体として、ルールを持ったデータベース、演繹データベースとして捉えることができる。これはPrologプログラム全体がデータベースであるということだから、データベースの表現としては最強のクラスに属する。一方、事実を表す本体のない（強制的に真）頭部のみの定義節による述語はリレーショナルデータベースとその集合論的な性質で一致する。収集した情報を一つの述語に対して多数の頭部のみを持った節の集まりとして定義することにより、オンメモリリレーショナルデータベースを構築することが可能である。しかし、Prologをデータベース管理システムとして捉えた場合、 assert、retract、setof、bagof、findall という組込述語を持つこと以外には、管理機構としての特別の組込述語が用意されている訳ではなく、ディクショナリ管理などのための述語定義をユーザが追加する必要がある。
関数型言語等、他のプログラミング言語と比較しての Prolog の特長は、上記、一階述語論理に基づくこと、単一化、データベース言語的性格の他に、非決定性と双方向性が挙げられる。
非決定性は、解が唯一とは限らない場合、処理系側から見てひとつの解に決定できない場合、外部からの選択の余地を与える。そういうことが当然可能なこととして述語は定義されていく。インタプリタトップではなく、導出を繰り返すプログラム内部にあっては、処理系側とした所を述語と置き換えて考えると、非決定性の述語の解を決定するのは、前方または後方に連接する質問(副目標という)である。前方の副目標群から引数経由で与えられる情報によって副目標は一つの解を作り出すが、この解が真であるとするのは最終的に後方に連接する副目標である。この後方に連接した副目標が全て真となった場合に限り副目標は真となる。後方に連接する副目標のどれかが真にならなかった場合は、それが存在すればであるが別解を用意しなくてはならない。ここでも非決定性の述語、ここでは副目標から見ての解の決定権は、外部にあるということになる。
非決定性は導出の過程、取り分けバックトラックアルゴリズムと一体化しており、Prolog プログラムの制御の根幹のひとつである。ただ、非決定性述語実行時に見られる論理変数の 束縛→解放→再束縛という遷移、すなわち一度束縛されたものが別のものに再度束縛されるということを好ましくないとする見方もある。
双方向性は、述語が実行された場合の返り値は真または偽だけであり、その代わりとして引数内の変数で値の授受を終始するのだが、このとき、入力として使われた変数が出力に、出力として使われていた変数が入力として使うことのできる述語となることがある。この性質を双方向性という。多くの場合、双方向性を持つ述語はそれ自体多義性を持つ。例えば append という3引数の述語は第一引数と第二引数に具体的なリストが来て呼ばれた時は、リストを結合する意味でよいが、第三引数がリストで第一引数と第二引数が変数の状態で呼ばれた場合その意味は、リストを分解する、がふさわしい。既に存在するリストを、それが結合されて存在したものと考え、それではどのように結合されていったか、あるいは、どのような組み合わせで結合されていったのかを、示していると解釈できる。
このような、双方向性は Prolog の述語自らがリバースエンジニアリング的開示能力を持ち、それを示していると捉えることができる。この性質は、Prologを含む論理型プログラム言語の持つ際立った特徴であり、プログラム作成時はもちろん、テスト、デバッグなどの検証の各段階でプログラムコードに対する見通しを向上させる。
プログラマは引数の単一化、再帰/失敗駆動等のプログラムパターンの選択、非決定性、双方向性といった特長をできる限り生かすことなどに配慮しながら、述語の骨格を決めプログラミングを進める。しかし、これらの特長、性質は複合した場合には相当に複雑であり、制御上相反する部分も多々ある。Prolog では、述語論理を逸脱して計算量/資源量/制御の調整に当たる述語「!」（カット）を導入してこの問題に対処しているが、Prolog プログラミングの難しさはこの調整部分に集中している。 　　
Prolog の性格上、その歴史には定理の自動証明の研究が大きく関係している。1930年にジャック・エルブランは自動定理証明やPrologのベースとなる数理論理学上の基本定理であるエルブランの定理を発表した。エルブランの論文には Prolog で必須の単一化アルゴリズムもすでに含まれていた[4]。
1950年代以降、計算機上での定理証明の研究が活発になり、ギルモアのアルゴリズム(1960)やデービス・パトナムのアルゴリズム(1958,1960) 、プラウィツによる定理証明への単一化アルゴリズムの導入(1960)などを経て、1965年のロビンソンによる導出原理 や1960年代後半のラブランドによるモデル消去の証明手続きの成果からひとつの結実期を迎えた。その数年後の1971年マルセイユ大学のアラン・カルメラウアーとフィリップ・ルーセルのグループは自動定理証明システムとフランス語の自然言語解析システムとを組み合わせたコンピュータとの自然言語対話システムを作成していた。この際に自然言語解析システムも自動定理証明システムと共通の論理式という枠組みで構築できることに気が付き、論理式をそのままプログラムとして実行できる最初の Prolog を1972年に完成させた[5]。これは数千年に及ぶ人類の叡智である論理学の成果をプログラム言語に置き換えたものと言えるが、現在の Prolog でプログラムの制御に使われるカットオペレータに相当する機能が最初から導入されるなど[6]、現在の Prolog と同様、単なる定理証明システムではなくプログラミング言語として設計されたものだった。以下にその当時の Prolog プログラムの一部を示す。論理変数名の最初の文字が "*" で始まるなど、現在の Prolog とはシンタックスが異なる。
彼らグループに理論的な助言を与えていたエジンバラ大学のロバート・コワルスキとデービッド・H・D・ウォレン[7]は汎用機 DECsystem10 上にマルセイユ大学とはシンタックスが異なる処理系を作り上げた。これは後に DEC-10 Prolog と呼ばれることになるが、ISO 標準規格を含む今日動作する Prolog 処理系はほとんどがこの系統のシンタックスに従っている。
コワルスキはその後、帝室ロンドン大学に移り、1979年に集大成ともいえる「Logic for Problem Solving」を著し、その後のこの言語と論理プログラミングの研究に決定的な影響を与えた。
コワルスキの活動と DEC-10 Prolog の存在によって、英国は Prolog 研究の中心地となった。エジンバラ大学のW・F・クロックシン[8]とC・S・メリシュ[9]の著わした「Programming in Prolog」は長く Prolog のバイブル本として利用された。エジンバラ大学からSRIインターナショナルに転じたディビッド・ウォレンは1983年 Prolog の仮想マシンコードである Warren's Abstract Machine（WAM）を発表した。この後の Prolog 処理系の実装は、一旦C言語などでこの仮想マシンコードを実装して、その上で Prolog のソースコードをこのマシンコードに変換するコンパイラを用意するという手順を踏むことによって、開発を簡素化し実装上の標準化を図ることが普通になった。日本の新世代コンピュータ技術開発機構の Prolog マシン PSI は1987～1988年頃に開発された PSI2 からこれを採用したし、その後開発された Prolog 処理系の多くはこの方式に従った。
1976年にSRIに留学していた古川康一はカルメラウアーらの Prolog 処理系のリストを見つけ帰国時に電子技術総合研究所に持ち帰った。当時電子技術総合研究所で推論機構研究室長をしていた淵一博はこのリストを解析して Prolog 処理系を走らせ、ルービックキューブを解くプログラムを作成するなど論理プログラミングに対する理解を深めていった。
1978年MITに留学中の中島秀之が「情報処理」誌に紹介記事を寄稿して、Prolog は日本でも広く知られるようになった。
1970年代終り頃、日本では通産省の電子技術総合研究所の淵一博を中心とするグループが論理プログラミングの重要性を認識して、日本のコンピュータ技術の基礎技術としてこれを取り上げることを提案する。これが最終的に1980年代の新世代コンピュータ技術開発機構の発足と活動につながった。総額約570億円の国家予算を約束されて1982年に新世代コンピュータ技術開発機構（ICOT）は活動を開始する。Prolog を含む論理型言語はこの研究の核言語と位置づけられ世界的な注目を浴びることとなる。約10年間の研究活動中に Prolog と論理プログラミングの研究は急激に深化した。実際1980年からの20年間に Prolog をメインテーマにした日本語の書籍は約50冊発刊された。ICOT の研究員は積極的に Prolog の啓蒙に努め、講習会、チュートリアル、ワークショップを年に一度ならず開催した。ICOT が主催したロジック・プログラミング・コンファレンスは1983～1985年頃をピークに若い研究者達を刺激した。研究活動前半の期間では論理型言語の実用性を証明するために、Prologマシンが設計され、三菱電機と沖電気によって製作され、ICOT の他大学等研究機関に配布された。この個人用逐次推論マシン PSI の機械語 KL0 は単一化やバックトラックなど Prolog の基本的特徴を完全に備えていた。この KL0 によって、PSI のマイクロコードを制御した。KL0 を基礎として、オペレーティングシステム SIMPOS が設計され、これを記述するために、Prolog にオブジェクト指向プログラミングを取り入れた ESP[10]が近山隆により設計されて使われた。ESPは多重継承を特徴とする当時としては先鋭のオブジェクト指向言語であったが、後にカプセル化の不備などが指摘されて、今日あまり話題となることはない。しかし、OSを記述するという課題を通じて、論理型言語にオブジェクト指向言語的要素を加えることによって、可読性が高まりプログラム管理がしやすくなることが確認された。その反面、Prolog のみでオペレーティングシステムを完全に記述してみる絶好の機会を逸したことも確かである。ESPはPSIを前提にせずに利用できるように、C言語で書き直したCESPが開発されたが、これが普及への起爆剤になることはなかった。後に述べるように、PrologのISO標準規格のモジュール仕様としてESPの採用が否決された1995-6年頃以降はほとんど利用されることはなくなった。
ここまで述べたように、Prologは ICOT によって持ち上げられた言語 Prolog との印象が強いが、Prolog というプログラミング言語から見ての ICOT の影響は実は限定的だった。淵所長ら ICOT の主研究テーマは並列論理型言語にあり、研究後半では Prolog そのものからは離れて行くことになる。PSI に使用した電子基盤を利用して並列推論マシン PIM が製作されて、Guarded Horn Clauses（GHC）に基づく並列演算処理を追加した KL1 が設計された。この環境に依存する形で、並列論理プログラム言語のKL1は知識プログラミング全般の研究に利用された。PSI と SIMPOS を使った研究も続けられはしたが、割り当てられた研究員の数は極めて少なかった。
ICOT の活動を総括して、知識プログラミング各課題において準備不足からくる未消化を指摘する向きが強いのだが、こと Prolog から見ての前半期の活動は、今日語られることも少ないが、極めて充実したものであったといえる。
ICOT の活動盛期の1984年京都大学の学生3名[11]が研究課題として製作した Prolog-KABA がその性能の高さとアセンブラで記述されたことからくる高速性で世界を驚かせた。この処理系は MS-DOS 上で製品化されて Prolog の普及に大きく貢献した。Successful pop や末尾再帰の最適化など高い安定した性能で黎明期のパソコン上のビジネスソフトの基礎言語としての展開も期待されたが、16ビットの整数しか持たず、浮動小数点数も扱えない仕様であったため、この分野への展開は起こらなかった。この点はアセンブラで記述されて簡単には拡張できない点が裏目に出た。結果としてこの仕様の乏しさが、日本のビジネスソフトが知識プログラミングの水準との間に横たわる分水嶺を越えることができなかった原因の一つとなった。
1990年代に入ると制約論理プログラミングが注目され処理系が多数誕生した。これは Prolog から見ると引数の論理変数間の関係（制約）を記述可能に拡張したものである。制約論理型言語は、変数評価に遅延実行などを持ち込むことが必要となるが、連立方程式をはじめとする多くの課題で Prolog より記述が柔軟になる。Prolog の組込述語には引数が変数で渡るとエラーとなるものが多く、このため Prolog プログラマは変数が具体化されるように副目標の記述順序に気を配る必要がある。結果としてプログラミングに逐次性が生じる。制約論理プログラミングにおいては、後に変数が具体化されたときに検査されるための変数の間の制約を記述するだけで、この逐次性の拘束を解決して通過することができる。実はこの制約はPrologから見ても自然な拡張であり、むしろ Prolog の単一化が制約論理プログラミングの制約を「=」のみに限定したものだと解釈することができる。しかし、簡素で逐次的な性格を強く持つ Prolog の処理系に慣れた利用者が、制約論理プログラミングの述語中に更に変数制約の宣言を追加しなくてはならない負担を、受け入れているとは言い難い。制約論理プログラム処理系が Prolog のそれに置き換わる気配は、2013年11月現在においてもない。
ISO の標準化作業は1987年頃から作業委員会(WG17)が作られ、日本委員も情報処理学会から15名ほどがこれに加わった。1995年 ISO標準規格がISO/IEC 13211-1 Prolog-Part 1: General Coreとして制定された。さらに、2000年にはISO/IEC 13211-2 Prolog-Part 2: Moduleとしてモジュール仕様が追加して規格化された。モジュール仕様については日本委員から、ICOTによって作成されたESP(Extended Self-contained Prolog)を以てその標準とする案が出されていたが、これは否決された。
ISO標準規格はエジンバラ仕様 DEC-10Prolog を基調に既に一家をなしていた Quintus Prolog など有力ベンダと主としてヨーロッパの学者を主体にこれに日本などの委員が参加して作成された。この規格は現在 Prolog 処理系の製作者に指針を与え、大きな逸脱を心理的に妨げる役割を果たしているが、組込述語の個々の仕様ではベンダの意向が強く反映されたものの、全体としては最初に述べた論理学的立場を尊重して保守的で極めて小さな仕様となっている。そのため多くの Prolog 処理系はこの規格の述語を搭載しつつ、独自の拡張部分を修正したり削除することに消極的である。結果として個々の処理系の互換性の乏しさは残り、それは Prolog の弱点として認識されている。
JIS規格も一旦は2001年にJIS X 3013:2001が、"標題 プログラム言語Prolog―第1部：基本部"が要約JISとして発行されたが、2012年1月に何ら実効を見ること無く、「周知としての目的は終了した」として廃止された。
日本において、ICOT の活動時期から1990年代前半に掛けては、いわゆる人工知能ブームの時期であり、人工知能研究への期待はこの時期再び異様に高まった。LISP マシンによる医療情報エキスパートシステムでの成果は、人工知能の研究の成果の一部は情報処理に於いても利用可能なのではないかとの夢を抱かせた。このような評価の中で Prolog は人工知能のアセンブリ言語的な位置づけを期待された。知識情報処理はこの水準の言語を基礎にその上側に築かれるべきだとの意味である。手っ取り早く利用可能な人工知能技術としてエキスパートシステムが選別され、これを支えるナレッジエンジニアの存在とそれを養成するための教育が必要とされた。Prolog はその中心に存在した。日本も例外ではないが、日本以外の国では特に、Prolog の名著は1990年代前半に刊行されている。これは、ICOT の活動とは若干のタイムラグがあるが、この時期社会的に 人工知能向き言語としての Prolog に大きな期待が寄せられていたことの証しである。エキスパートシステムはビジネス分野において広範囲に応用可能な基礎技術であったが、このような低水準な分野への適用はあまり試みられず、この分野からの Prolog 言語への要請はほとんど見られないまま終った。
機械翻訳などの自然言語処理もまた人工知能の一翼を担う分野であるが、歴史的経緯から人工知能ブーム以前から、この言語に最も期待が掛けられた分野であった。しかし、左再帰問題の回避でトップダウン解析の明解さをいきなり殺がれた。さらに句構造文法への適用においては、Prolog が得意とする、句構造に分解して意味に相当するグラフを形成することの他に、極めて膨大な辞書を構造体として定義する必要が展望された。この辞書作成は Prolog とは直接関係しないタスクであることから、次第に Prolog は句構造文法によるアプローチの前線から後退してしまった。統計的言語処理のアプローチでは、単一化等に多くの計算量を費やす Prolog は大量データを扱うのに不向きとされて、利用されることはほとんどない。自然言語処理のテキストの多くが Prolog を用いて解説されているにも関わらず、期待が大きかった割に実務的には、表面に現れている成果はIBM社のワトソン程度にとどまり、自然言語処理はむしろ Prolog 評価の足を引っ張る傾向にさえある。
日本においては、ICOT 解散後数年を経て、論理プログラミングと Prolog は急激に下火となる。先にあげたコワルスキの成果があまりにも完成されたものでその研究成果の範囲を越えることが難しかったこと、歴史的にプログラム言語でありながら論理学からの逸脱を厳しく制限され、自由なアイデアによるプログラミング言語としての発展・展開が困難に見えたことも研究者・技術者を離れさせた。そして、人工知能ブームもまた去って行った。企業等で続けられた研究開発も発表される機会がProlog産業応用シンポジウム（INAP）などに限定され、人々の目に Prolog の成果が触れることは極端に少なくなった。ICOT の多大な研究成果がネット上に閲覧可能な状態で置かれたが、Prolog 言語の処理系はインターネット時代の技術・流れに乗れず、初心者・初学者が利用するためのネット上での情報も他の有力言語に比べて少なく、新しい利用者を惹きつけることができなかった。パソコンのオペレーティングシステムとして Microsoft Windows が一般に普及し始めると、初心者教育にウィンドウの部品の展開を題材とするのに適したオブジェクト指向言語に人気が集中し、Prolog は動作の遅い外れた言語のイメージを持たれるようになる。さらに21世紀に入ると Prolog がクラス概念を持たないため、マイクロソフト社による .NET アーキテクチュアの共通言語基盤（CLR）の対象言語から外され、この傾向に拍車をかけた。ついには枯れた言語というニュアンスを含んでではあるが、「化石言語」と揶揄されるまでに至ったのである。
盛時の勢いは失ったものの、Prolog は各教育機関で主として論理学の教材として利用され続け、今日まで数万人の人が Prolog の講座を受講している。実務的に利用される機会が少ないにも関わらず、その素養を持つ人が大量に存在するという特異な位置にあるプログラム言語となっている。また、多くのプログラミング言語でその言語上にPrologインタプリタを制作してみることが難度の高い学習課題の一つとして採用され、その結果としてもPrologを理解しているプログラマは増加する傾向がある。

2011年夏、ブルース・A・テイト[12]著『7つの言語 7つの世界』が出版され、その7つの言語の一つとして Prolog が紹介されたことから、多くの人々の関心を呼び起こし、この言語は突然に息を吹き返した。ダニエル・ジャクソン[13]著『抽象によるソフトウェア設計』も翻訳されて述語論理に基礎を持つ形式記述言語 alloy が注目されるなど、Prolog に極めて親近した領域での議論がようやく活発になった。
2012年に入り、イワン・ブラトコ[14]著「Prolog Programming for Artificial Intelligence」の第四版が11年ぶりに刊行されて、人々に Prolog は今でも活火山的な存在であることを印象付けた。また、世界的に利用されているアプリケーション自動生成ツール GeneXus が Prolog によって書かれてからそれを他の利用言語に変換されて製品化されていることや、IBM 社のワトソンの根幹部分である言語解析部分と質問の生成部分を現在も Prolog が担っていることなどが次々と喧伝されて、応用面でも現役言語であることが改めて認識されつつある。さらに世界的な関数型言語への急激な関心の高まりによって、関数型言語と類縁性の高い論理型言語の盟主であり、人気関数型言語 Erlang の原像でもある Prolog への関心は再び強まってきた。

2013年IBMはワトソンの商用化を積極的に進めることとし、研究開発要員を2000名に増強することを発表した。さらに2014年秋、ソフトバンクとの間でワトソンの日本語化で提携することが発表された。ソフトバンクは既にADSLの故障診断をPrologで開発して利用してきた実績があり、既に公開され、2015年春出荷が予定されている感情認識パーソナルロボットPepperでも中核部にPrologを採用することが予想されている。同社がワトソンと強く結びつくことによって、Pepperが将来ワトソンから情報を受け取ることによって、どのように強化されて、変化していくのかということが俄然興味深い問題に浮上した。同時に、その二つのシステムに跨って、Prologがどのような関わりを持つのか、役割を担うのかということも注目されている。
プログラムは、ホーン節、もしくは単に節と呼ばれる形式の項を並べたものである。
節は、頭部と本体部からなり、
または
の二形式があり得る。これはそれぞれ、

頭部.　　　　　　の形式が「AはBである」、
頭部 :- 本体部.　　の形式が「AならばBである」という命題の形式に対応する。

節も項であって、項は関数子といくつかの引数からなる。
節の関数子は ':-' であり、頭部と本体部はその引数である。関数子が':-'の二引数の項が節である。
の形式は実は、
が省略されたものと見なされ、やはり ':-' を関数子として二引数の項である。

頭部は項が連接することはできない(ホーン節)が、本体部は項が連接する、そういう項であり得る。
頭部 :- 副目標1,副目標2, ... 副目標n.
副目標1,副目標2, ... 副目標n　は、これ全体を目標という。目標は副目標1...副目標nの連言である。
ここで 目標 = ( 副目標1,副目標2, ... 副目標n ) と置けば、
であり、やはりこの節の形式も、関数子 ':-' の二引数の項であることが分かる。
複数の副目標はカンマで区切られているが、このカンマは論理積を意味する。
節は、その頭部の形式、すなわち関数子とその引数の数が同一の形式を持つ述語と呼ばれる単位で管理される。

プログラムは項の集合であり、節の集合であると同時に、述語の集合でもある。
Prologはこの項、節、述語だけでその形式を表現できる点で、他のプログラム言語とは著しく異なる。これはPrologの理論的な背景が論理学にあり、この中の概念のみで構成されて、発展してきたからである。
このような節の集合をあらかじめ用意してそれを定義した上で、ある命題が真であるかどうか問うことを質問という。 節の集合、つまり述語の集合をあらかじめ用意する方法については、後出の"Prologプログラミング"で述べる。

Prologの処理系は、人間の入力した質問に対して、頭部が形式的に一致する節があるか調べ、あった場合はその本体部に記述されている命題と一致する節があるか再帰的に調べる。
ここでは定義されたもの(処理系があらかじめ用意した組込述語も含めて)だけが、真になり、定義されていないものは必ず偽となる(閉世界仮説)。
具体的な例を見よう。
「ソクラテスは人間である」「人間は死ぬ」を Prolog で記述すると以下のようになる。ここで X は変数である。
人間(ソクラテス). は「AはBである」の命題の形式に対応し、ここでは、Aはソクラテス、Bは人間である。同様に、
死ぬ(X) :- 人間(X). は「AならばBである」であり、Aは人間(X)に、Bは死ぬ(X)に対応している。

システムに対して以下のように入力すると、true が返される。
これは「ソクラテスは死ぬか」と質問したことに対して、システムが内部で推論を行なって、既知の知識から答えを出したものである。
それではここでの既知の知識とはなんであろうか。それは、
であり、内部で行っている推論とは、?- 死ぬ(ソクラテス). から 死ぬ(X) :- 人間(X). により導出されて、
が、確認される過程である。
今度は以下のように入力してみる。これは、「死ぬのは誰か」と質問したことと同じになる。この場合もシステムが内部で推論を行なって、死ぬ（X）を満たすXを表示する。
他のプログラム言語に比べると質問を基本的骨格としている点でユニークであるが、更に、Prolog は複数の計算結果があり得るという点でも極めてユニークなプログラム言語である。先のプログラム例を拡張して
とした場合、死ぬ（X）を満たすXは複数（ソクラテスとアリストテレス）がありうる。
述語 人間　に複数の節を設けて、その引数にソクラテス、アリストテレスと列記して行くだけで、質問に対して複数の解を処理系が列挙するようになる。
他の言語でこういう機能を実現する時に見られるような、手続き的なループや情報を管理する配列の添字管理のようなものは全く現れない。
多くのProlog 処理系ではこのような複数解が存在する時に新たな解を得る場合は
と ";"（セミコロン）記号を用いて他の解を得る。";"はこの解は真ではない、という質問者の意思表示である。
ここではインタプリタのトップからの質問、すなわち対話環境にあるから、X = アリストテレスが処理系からの質問者に対する応答、質問となっている。
質問者は「この解は真ではない」と否定することができる一方、呈示された解(ソクラテスまたはアリストテレス)を真と決定することもできる。このように処理系から見て外部からの介入によって真を得ることを非決定性という。
この非決定性がコンピュータ言語としてのProlog の際立った特徴の一つである。
もうすこし具体的なPrologプログラムの例を以下に示す。「%」から行末までは注釈である。
member(X,Y) は要素XがリストYのメンバーであるかを調べるプログラムであると同時に、「要素XがリストYのメンバーである」という関係も宣言的に表している。実行例を以下に示す。
要素XがリストYのメンバーであれば成功する。
要素XがリストYのメンバーでなければ失敗する。
Xの部分を変数のままにすると、リストYのメンバーである要素が結果として返る。すなわち、ジェネレータとして働く。
二つのリストの共通メンバーを求めるには単純に","で区切って並べればよい。この","はANDの意味を持つ。
要素Xを指定しリストYを変数のままにすると、それらがメンバーであるリストが結果として返る。
上の"_G001"はProlog処理系が作成した仮の変数で、リストの後半が不定であることを示す。
Prologが扱うデータは項（英: term）と呼ばれる。項は定数、変数、複合項のいずれかである。
複合項でのアトム部分を関数子（英: functor）、引数の数をアリティ（英: arity）と呼ぶ。アトムはアリティが0個の複合項とみなすこともできる。アリティが異なれば同じ関数子でも別のものとして扱われる。アリティは英語に由来し、英語の語彙としても馴染みの少ないものであるが、適切な訳語が見つからず現在もこの表現が使われている。
前置・中置・後置記法された複合項は、複合項の関数子を前置・中置・後置記法の演算子として定義したものだが、これは表記法の問題でしかない。Prologではユーザが任意の演算子を定義できる。いくつかの演算子が事前に定義されており、例えば、算術式での"+","-","*","/"などが代表である。 X+Y*3 は実は複合項 '+'(X,'*'(Y,3)) として処理系に解釈され、そのような構造体を表現するものとして実装される。また、 死ぬ(X):-人間(X) は ':-'(死ぬ(X),人間(X)) に等しい。このことから、Prologのプログラムは複数の項、すなわち述語 :- の集合、として記述されていると考えることができるため、プログラムをデータとしてProlog自身で処理することは比較的容易にできる。
ユーザが演算子を定義するには、組込述語op/3を使う。下記のようにプログラム中でop/3の実行して宣言を要求することもできるし、インタプリタのトップから ?- op(600,xfx,は). のように実行して直接宣言することもできる。opの第一引数は項の結合強度を、第二引数はオペレータの型を表す。演算子は第三引数で指定する。
死ぬ(X) :- 人間(X).を
と定義すると、述語は は/2,が/2 に変わってしまって、全く別の定義だと言えるが、我々には意味的に同様のものと理解できる。これは中置記法の例であるが、以下のように、前置記法の"必ず"、後置記法の"ならば" を加えて意味的に補強することも可能だろう。( _ :- _ の中にその義を含むから、本来その必要はないが)
Prologは動的型付き言語であり、型を宣言することはしない。論理変数は関数または述語の引数の中にしか現れず、この変数の型を指定する(例えば integer:X のような)記述をしたとしても、その変数を型に制約することはできない。
質問がなされ述語が呼び出された時に処理系は単一化のルールによって論理変数を可能であれば束縛するが、その際、型を検査することはしない。その引数が例えば、整数であるか、あるいは浮動小数点数に束縛されているかは、組込述語 integer/1 float/1 でそれを随時質問することによって検査することができるのみである。
複合項の中で特別な扱いを受けているものとしてリストがあり、LISP以来の記号処理プログラミングの伝統に則りPrologでも極めて多用される。実際のところ、Prologのデータ構造は単位節定義とリスト以外にはないと言っても過言ではない。
リスト'はいくつかの項を順に並べたもので、その先頭要素を取り出せば、残りはまたリストであるというように再帰的である。例えば [a,b,5] のように、要素となる項を「,」で区切り「[」と「]」で囲った形で表現する。要素のないリストは [] と表記し、空リスト、あるいは nil と呼ぶ。
リストをグラフとして示すと、 リスト [a,b,5] の構造は
のようになるだろう。
Prologのリストの表記として、要素を"|"で区切る方法がある。この記法があるためにPrologのリスト処理は視覚的で読みやすい。先頭からいくつかの要素の後に"|"が来て、その後にはリストか[]が来る。 例： [a,b,c,5,6] は、先頭の要素 a,bと残りの要素 [c,5,6] をつなげた [a,b|[c,5,6]] と等価である。 ただし、[[a,b]|[c,5,6]]ではない。Prologの複雑なリスト処理をそれでも宣言的と見なすことができるのは、専らこの記法あってのことである。
この記法はPrologのプログラムではリストを先頭要素と残りリストに分解する場合に多用される。[1,2,3]=[H|R]の場合、Hは単一の項(複合項であることも含めて)を表すパターンだから、H=1,R=[2,3] に分解される。後に示されるプログラム例の章には、リスト要素の加算,append,組合せ,クイックソート 他、多数の事例がある。重複するからここでは二例だけを示す。
Prologを代表する述語 member/2 の[H|T]と[_|T] と append/3の[H|X]と[H|Z] の所にこの記法が使われている。
 ?- member(H,[1,2,3]). にあっては、第一番目の定義節から
[1,2,3] が [1|[2,3]] に分解できて H = 1, T = [2,3] となるから、最初の解である
が表示されるのである。
以下では、二つのリストを単一化することを通して、リスト記法の各部分がどのような関係にあるかの理解を深めよう。
最後の例の[a,b|c,5,6]のc,5,6はリストと看做されない。

'|' を使ってリストを区切る用法もグラフ化すると、リスト [a|[b,c,5,6]] = [H|T] の構造は
である。

リストは簡単に成長させることができる。
リストを成長させる/3では単一化のからくりを巧みに使って、リストの先頭に要素を追加している。
リストの要素をひとつ切り取るには、反対に
リスト要素の切り貼りはこのようなパターンで行われる。リストは先頭から要素を加え、先頭から要素を検査し、先頭から要素を取り去るのに適したデータ構造を持っている。

ここまで示してきた通り、リストは読みやすいように特別な表記法を与えられた複合項であるが、実は一般の複合項と同様の構造で実現されている。 リストは関数子名が'.' と決められていて、以下の例のように実現されたアリティが2の複合項である。 例： [a,b] は複合項 '.'(a, '.'(b, [])) と等価である。

形式記述言語の多くがそうであるように、Prologはその制御の大半が再帰処理によっている。リストは再帰的な構造データの中でも最も簡素で扱いやすいものであり、制御構造とデータ構造の一致という点からもリストが多用される十分な理由がある。
複合項もまた再帰的構造データではあるが、生成、分解、置換などの際の扱いが複雑になるため、グラフやオートマトンなどの定義/表示以外にはあまり使われない。'.'(a,'.'(b,[]))の構造で分る通り、リストも実は複合項である。リストは生成、分解、置換などが容易くできる構造を持つ特別な複合項であり、それ故に特別な表記法を与えて、さらなる便宜を供しているのである。

Prologではリストの内包表記はできない。setof や findall の表現が意味的にそれに近いが、ここでの表記をリストを表す項として、遅延して評価するために持ち回ることはできない。
例えば
であるが、findallを関数表現として、
と表記したとしても、この項だけ例外的に単一化を免れ関数評価する特別な機構を付加しない限り、この第一引数はリストと看做されることはなく、エラーとなり、Lに期待する [2,4,8,10] は得られない。このことから単一化がリストの内包表記を阻んでいる理由の一つであることが解る。

Prologには集合を表す特別な表現がなく、リストでこれを代用するのが普通である。この問題については、Prologプログラミングの 章で詳述する。
Prologの実行は述語を定義された処理系に対してユーザが質問することによってなされる。質問とは、
のようなものである。ここでの質問は「ふねはタラオの親か」という意味だ。「ふねとタラオは親子関係である」という読み方もある。
このような質問に処理系が答えることができるためにはその知識が必要である。Prologではこの知識を述語という形式で与える。そのことを述語を定義するという。
定義された述語には一般に処理系によって最低限必要なものとしてユーザに対してあらかじめ用意された組込述語(ユーザは定義しなくてもよい)と、ユーザが自ら定義したユーザ定義述語の二種類がある。ユーザは自ら定義した述語群をファイルに保存して、そのファイルを組込述語であるconsult/1述語によって処理系に読み込ませる。
サザエさんの家系図に関する述語群が
上記のように、エディタなどで書かれて、ファイル'sazaesan.pl'に存在するとして、
を実行することによって、サザエさんの家系図に関する述語群がユーザから参照できるようになる。
はプロンプトと呼ばれ、質問を受け付ける準備ができていることを示す。プログラムを実行するのには、一般にProlog処理系の起動後、最初のプロンプトが表示されてからユーザ自身で質問(目標)という形でプログラムを実行する。
実務的なプログラムではこの質問によって述語定義の融合、頭部の単一化、本体部の導出の長い連鎖となり、最終的にその質問が真か偽の結果を残して終了する。
これが普通の使い方だが、処理系の起動時にコマンド引数などで最初に実行する質問を引き渡して、起動後停止することなく、質問が実行される場合もある。
ここでlistingという質問を与えてみる。この組込述語は現在実行可能な状態にある述語すべてのソースコードを表示する。
このように定義済みであることが分かった。これが先の?- consult('sazaesan.pl').の効果である。
最初の親子(波平,サザエ). から 夫婦(マスオ,サザエ). までが事実であり、形式的には本体がなく、単位節と呼ばれる。 その下の member は二番目の節に再帰的に本体があり、これはルールと呼ばれる。
ルールmemberを使った質問をしてみる。
となる。サザエは集合{波平 サザエ マスオ} の要素であるかという質問に真と答えている。
さらに簡単な質問をしてみる。単に事実を問うものだ。
この質問で第二引数に X 乃ち論理変数が使われた。処理系はこのXに適切な値が入ることで、この質問を真となって終わらせようとする。
X に カツオが入った時、
で真となるし、ワカメが入った時、
で真となる。
この二つの質問を 論理変数 X を順に束縛することで満たしているのが上の ?- 親子(ふね,X). での実行結果である。
質問の詳しい説明は後のプログラム例「家系図」以下にある。
Prologの処理系は質問がなされ、それに回答を繰返すことによって処理が進むという作りになっている。
しかし、質問することなしに、処理系の起動時にプログラムを実行することももちろんできる。最初に現在処理系で使われている代表的な二つの方法を示す。

1) ソースプログラムの中に起動する質問を記述する。
2) 処理系の起動時に -f ファイル名 オプションを指定すると共に、-t オプション等で、最初の質問の述語名を直接指定する。(例えば mainなど )
　　 ・ # prolog -f sazaesan.pl -t main

必ずしも処理系起動時と限らないのだが、consultされるファイルの途中に特別な述語 :- を指定して、自動で質問が実行できるようになっている処理系が多い。 ファイル'sazaesan.pl'の第一行目に
が書かれているとすれば、
を実行した直後に
%%% サザエさん家系図の読み込み %%%
と表示される。'sazaesa.pl'の第一行が読み込まれ、処理系が :- から始まる特殊な節を見つけると、
という質問をユーザからの入力なしに実行する。
この機能を利用して、処理系の起動時にコマンドラインに -f オプションなどで初期読み込み述語ファイル名が指定できる作りになっている処理系が多く、
この ':-' 述語をファイル内の適宜な場所に記述することによって、質問の自動起動が可能となる。
しかしながら質問で変数束縛の状態表示を期待している場合は、質問ー応答モードを脱して動いとしまっているから、:-以下での質問に対する実行が完了した場合でも質問ー応答する場合のようにはうまくいかない。";"や改行待ちとなる非決定性の制御にも移行しない。このような変数束縛の表示はwriteのような出力述語を続けて記述してユーザが表示させる必要があるだろう。
自動実行を理解しやすくするために、'sazaesa.pl'に少し :- 節を追加してみる。
これを'sazaesan.pl'とは別のファイル'temp1.pro'に書いて置くとする。
組込述語 writef/2 や fail;true 制御についてここでは詳しくは述べないが、
最後に処理系を終了させる組込述語 halt. を実行させることにより、
のような、バッチ処理プログラムとして実行することができる。
起動述語として例えばプログラムの起動時コマンドオプションで -t main を指定する場合は、予め、
のように述語として定義して置けばよい。

組込述語 consult/1 の事例を示したが、Prologの処理系は共通の組込述語群とその処理系独自の組込述語群を持っており、後者が統一されない状態であることは歴史の中で触れた。ユーザは各処理系のマニュアルを注意深く読む必要がある。
Prologでプログラムを記述する単位は述語（英: predicate）で、他の言語での関数やサブルーチンに相当する。つまり、Prologプログラムは述語の集まりで、述語はあるまとまった機能を表現している。述語は1つ以上の節（英: clause）と呼ばれる項からできている。節は以下の形をしている。
あるいは、
1つの述語に属する節は、同じ述語名(関数子名)と引数の数(アリティ)を持つ頭部からできている。述語名とアリティが異なれば別の述語とみなすため、述語を指定するときは"述語名/アリティ"と表記されることもある (例： member/2) 。
1つの述語は成功、あるいは失敗のいずれかの結果を返す。副目標1～副目標nの間の "," はANDを意味する演算子であり、1つの節が成功するのは本体部がすべて成功した場合である。
本体部の実行は、副目標がANDの関係で連接する場合、記述された順に行われる。頭部のみの節は 頭部 :- true. と同じ意味であり:-trueが省略された形式だと考えればよい。

1つの述語が複数の節からなる場合、上から順に実行され、どれかが成功したら述語自体は成功する。つまり同じ述語内の節の関係はORの関係となる。節同士はOR関係であり、それぞれ情報の共有という観点からは完全に独立している。
一つの節の中の副目標から、同じ述語の別の節中の情報にアクセスするためには、新たにこの述語を目標(質問)として呼び出す必要があり、この場合、制御や変数束縛等は完全に初期状態での実行となる。
一度trueになった節で一旦は変数に値が束縛(代入)されていたとしても、バックトラックして、それより下の節に制御が移った場合は、制御の移った節からバックトラックした(すなわち偽となった)節の変数束縛を利用することはできない。

述語は親となる目標(副目標)によって謂わば質問として呼び出される。これに対して、述語の各節は予め備えている状態にある。質問されることによって、頭部の単一化を行い、これに成功した節の、本体の副目標を順次、今度はこれが親となって質問する。そういう備えができている。それが述語が定義されているということである。
Prologの基本的なアイデアは、ホーン節をプログラムと見なして実行する、ということであるため、純粋なPrologのプログラムは手続き的にもホーン節に従って宣言的にも解釈ができる。1つの節の解釈は以下のようになる。
手続き的に見ると、"副目標1"～"副目標n"がすべて成功する場合、節は本体部を順番に実行する関数やサブルーチンのように見なせ、再帰呼び出し可能な手続き型/関数型言語と動きはさほど違わない。他の言語との大きな違いは、本体部のいずれかが失敗した場合、最後に選択した節にバックトラックし次の節から再度実行を続けることである。
Prologの動作をプログラムが指定した条件での解の探索として見ると、深さ優先の解探索ととらえることができる。
C言語など通常のプログラミング言語の変数は値の格納場所であって、計算が進むに従って内容が変化する。Prolog などの論理型言語での変数は数学的な変数に近いもので、何らかの値につけた名前である。値は決まっているか決まっていないか(代入されているか代入されていないか)のいずれかで、一度決まってしまえば値が他の値で置き換わることはない。値が変わるのはバックトラックにより代入が解かれた後に再度値が決まった(代入された)場合のみである。この変数は他のプログラム言語のそれのようにプログラム中に宣言することはできず、述語或いは述語呼び出しの引数の位置にのみ現れる。
通常のプログラミング言語の変数と区別するために論理変数と呼ばれることもある。論理変数が述語または質問の引数の位置にのみ現れるという意味を理解しやすくするために以下の例を示す。
Y=Y,Y=Z,Z=3.のX,Y,Zは一見プログラムの中に宣言しているように見えるが、全て組込述語=/2の引数である。Prologにおいて=とは単一化を施すという意味である。
変数の値の変化の例：
論理変数は、格納場所ではなく、質問がなされる度に定義節を写して生成される一時的な論理域に存在するもので、プログラムの他の箇所からその値が参照されることはあり得ない。
第一節にXが二箇所、第二節にはXとRが二箇所現れている。それぞれの変数が最終的に同一のものに代入されることの宣言である。
また上記の定義では第一節と第二節にXという論理変数が現れているが、この二つの論理変数名が同一であることには意味がない。第一節のXに値が代入されて解が得られた後、バックトラックされて第二節に移行したから値が解放されて、Xは代入されていないのではなくて、第二節のXは第一節のXとは元々無関係だから、代入されていないことになる。
論理変数の名前が同一であることが意味を持つのは、質問されて、述語のひとつの定義節と融合された時、その融合された定義節側の頭部、本体の中に、質問としての副目標の引数とは無関係に、同名の論理変数があるかないかだけである。融合の際の頭部の単一化でさえ、論理変数同士の単一化であっても、変数名が同じあるか否かは問われない。この点については、次の節の単一化を参照。
ここで起こっている質問としての副目標(または目標)と定義節との融合は、述語定義のコードからは離れて、対応する節の姿が写されて実行されるのであって、その実行と述語定義のコードは直接的な関係を持たない。
したがって、この質問、導出過程で論理変数が束縛されても、述語定義の他の定義節の論理変数に影響を及ぼしようがないのである。
Prolog の動作の基本は単一化と後に述べるバックトラックである。
単一化(ユニフィケーション)は、述語呼び出し時に使用される、呼び出し側、呼び出される側双方向の強力なパターンマッチングだが、そのルールは簡単である。
すなわち、二つの項の単一化において、
以上挙げた以外の場合は、単一化は全て失敗する。したがって、アトムと複合項の単一化は常に失敗する。述語呼び出し時の候補節では、一つでも頭部にある引数の単一化に失敗すると、その候補節は選択されない。
1 と 2 は意味的に統合可能であり、単一化ルールを三つとすることもある。Wikipediaのユニフィケーションの説明ではそうなっている。しかし、変数の単一化は値が代入されないという意味で特殊であり、Prologでは同一性のみ主張できる変数の制約そのものであり、Prologの最も独自性の強い部分であることから、ここでは独立したルールとして扱う。
単一化によって論理変数がある値に決まることを、代入という。一般のプログラム言語の代入と表現は同じであるが、Prologの代入はある値をその論理変数を通じて覗くことができる。あるいは、この値が参照(利用)可能な状態になるといったニュアンスに近い。なぜなら、この代入がバックトラックによって「解かれる」と論理変数は再び何も参照できなくなる。
単一化は処理系が述語を質問として呼び出す(目標が実行される)たびに、暗にPrologシステム内でに実行されつづけているのだが、利用者が明示的に二項の単一化を指定することもできる。それが先の論理変数の事例に現れた = である。述語 = は左右に二つの引数を持ち、この二つの項の単一化を試みる述語である。
ここで、明示的な二項の単一化(=/2)を組み合わせて単一化の説明を試みよう。
単一化は極めて強力なパターンマッチングではあるが、実行コストも多大である。Prolog処理系の実行速度が他のプログラム言語のそれに比べて遅いことの主要な原因は単一化にある。
通常のプログラミング言語との比較で考えると、Prologの単一化は以下の機能を含んでいる。
バックトラックは他のプログラム言語と比較してPrologを特徴づける部分である。バックトラックとは後戻りくらいの意味だが、現在まで日本語として適切な訳を見つけられず、このバックラックがもっぱら使用されている。プログラムのコードとして明示的に指示がないにも関わらず、暗に実行コードが既に実行を済ませた部分に後戻りして実行を始める、そういう制御のことをバックトラックと呼んでいる。
質問が
とされたとする。
これから、p3(副目標という)が実行されると考えよう。p1,p2は成功裡に終了している。(ここでは副目標を抽象化して Pn の形式で表すこととする) このp3が成功(真となる)すると実行はp4が呼び出され、その定義の第一節に移る。 ところがp3が失敗(偽となる)すると、p2,p1の順に、まだ実行されていない、候補節が残っているものを探し、それがあれば、そこから実行される。 この後戻りして、実行する制御のことをバックトラックという。
p2に候補節がなく、p1にまだ候補節があってここから実行される時には、p3を含むp2以降に生じた変数の代入は完全に解消されている。 p1にももはや実行されていない候補節がない場合、最初の質問?- p1,p2,p3,p4,p5.が偽となる。
ここで候補節が残っている、または残っていないと書いたが、既に概要のところで述べられた非決定性の述語だけが、この候補節が残っている状態に成り得る。副目標の述語定義が決定性である場合は当然候補節は残っていない訳だから、?- p1,p2,p3, ... に於いて、p2が決定性の述語だったとすれば、p3がバックトラックすれば次はp2をスキップしてp1の残り候補節を探すことになる。
述語Q の定義が以下の場合に ?- q. が実行されて、上記のようにP3が失敗したとする。
p3が失敗して、もはやp2,p1にまだ実行されていない候補節がない場合、次の実行は第二節のp6に移る。つまり、qの第一節は失敗して、第二節(まだ実行されていない)に移る。のように、Prologの実行制御を把握するためには、pnの真偽だけではなく、pn-1,pn-2,...や、そのpnを呼び出しているqの実行状況まで視野に入れる必要がある。
たとえば、以下の述語に対して、
以下の member(Z, [ワカメ,マスオ]) というゴールを指定すると結果は次のようになる (";"を1回入力しバックトラックを行わせた例) 。
複数の解がありうる述語member/2に於いて、処理系は質問者に最初の解候補 Z = ワカメ を示したが、
質問者は";"を入力することによってこれを否定した(非決定性)。
続いて処理系が Z = マスオ という解候補を示し、
質問者はそれを受け入れて、改行した。これがこの実行の解釈である。

具体的に、member/2で解候補が選択される過程を追ってみると、
まず最初の節の頭部
で単一化が成功し、 Z=ワカメ で member/2 自体も成功する。
この状態でバックトラックを行わせると、次の節である2番目の節の頭部
で単一化が成功し、その本体部( ... の部分)を
として実行することになる。
これは、最初の節の頭部
で単一化が成功し、 Z=マスオ で member/2 は成功する。質問者は"."を入力することによって、これが解であることを受け入れた。

非決定性の述語の解の決定権をここでは質問者が持っている。しかし、このように質問者が介在することはPrologプログラミングの中では寧ろ特殊な場合であって、多くの場合、非決定性の述語の解を最終的に決定するのは後続する副目標である。
これは、タラオの親はワカメかマスオかという質問になっている。解はもちろんマスオだが、これを決定したのは、質問者ではなく親子(A,タラオ)という副目標であり、親子(マスオ,タラオ). という定義から導かれる論理が member(A,[ワカメ,マスオ]) の解をマスオに導いた。このようにmember/2からの視点で述べると、解を決定したのは質問者であったり、後続の副目標であったりした。すなわちmember/2にとっての外部である。述語自体は解を決定できないから、外部の導きによって最終的な解を選択するのだと考えればよい。非決定性述語の非決定性とはそんな意味である。

バックトラックは通常のプログラム言語には存在しないProlog独特の機能だが、強いて他のプログラム言語の中から類似したプログラミング要素を探すと、
が挙げられる。
ループの簡単な例を以下に示す。この例ではリストの先頭から0以上100以下の数値が見つかるまで繰り返す。
確かにこれはループではあるが、0以上100以下の数を取り出すというものだ。実際には3000,1254はX=<100で、-2は、X>=0で偽となってバックトラックしているのだが、Prologプログラマはそのような細部を行ったり来たり目で追うことはしない。
手続き型言語では探索機能を実装することは大きなタスクとなるが、Prologは非決定性述語を中心にプログラムを書くものであり、すなわちプログラミングとはバックトラックしながら探索することである。
X+Y*3 などの数式は単なる複号項にすぎない。数式を評価するには"is"などの述語を使う。以下にいくつかの述語の例を示す。
引数の単一化は X = Y に相当し、数式として評価可能の項が渡されても、評価されず単一化される点にに注意が必要である。

